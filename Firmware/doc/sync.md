# gkos synchonization primitives #

gkos provides standard synchronization primitives (spinlocks, mutexes, semaphores, conditions, queues etc) in inc/osmutex.h and src/mutex.cpp.

An added complication for the STM32H747 is that it does not implement bus locking so there is no ability to perform atomic loads/stores to memory.  This makes syncronization between the M7 and M4 cores more challenging and required the extra step of using the HSEM peripheral to guard the counter variable inside a spinlock.  As an abstraction, the cmpxchg<>() and set<>() template functions are provided in inc/util.h with the relevant atomic semantics.

gkos does not have separate kernel threads for each userspace thread.  All kernel code, including syscalls, is run on a per-core MSP thread.  Therefore, task switches cannot occur within a syscall and must occur on return to user mode.  This means that some syscalls must run multiple times to obtain a mutex lock (although they will typically Yield() immediately on return from a _trylock() function if they didn't obtain the lock).  Process inheritance is also supported for mutexes - if a high priority task tries to lock a mutex owned by a lower priority task, then the mutex being waited upon is stored within the high priority task TCB and the task immediately Yield()s.  During the next task selection, the waiting high priority task has its timeslice used by the task holding the mutex instead.  Once the mutex is released, the lower priority thread (via a flag in the mutex) knows to Yield() so that the high priority task can run again.
